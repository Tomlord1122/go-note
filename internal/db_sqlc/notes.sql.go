// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createNote = `-- name: CreateNote :one
INSERT INTO notes (user_id, title, content, embedding, tags, is_public)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, title, content, tags, is_public, created_at, updated_at
`

type CreateNoteParams struct {
	UserID    pgtype.UUID     `json:"user_id"`
	Title     string          `json:"title"`
	Content   string          `json:"content"`
	Embedding pgvector.Vector `json:"embedding"`
	Tags      []string        `json:"tags"`
	IsPublic  pgtype.Bool     `json:"is_public"`
}

type CreateNoteRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	IsPublic  pgtype.Bool        `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (CreateNoteRow, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.Embedding,
		arg.Tags,
		arg.IsPublic,
	)
	var i CreateNoteRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.Tags,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNote = `-- name: DeleteNote :exec
DELETE FROM notes
WHERE id = $1 AND user_id = $2
`

type DeleteNoteParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteNote(ctx context.Context, arg DeleteNoteParams) error {
	_, err := q.db.Exec(ctx, deleteNote, arg.ID, arg.UserID)
	return err
}

const getNote = `-- name: GetNote :one
SELECT id, user_id, title, content, tags, is_public, created_at, updated_at
FROM notes
WHERE id = $1
`

type GetNoteRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	IsPublic  pgtype.Bool        `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetNote(ctx context.Context, id pgtype.UUID) (GetNoteRow, error) {
	row := q.db.QueryRow(ctx, getNote, id)
	var i GetNoteRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.Tags,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNoteForFlashcard = `-- name: GetNoteForFlashcard :one
SELECT id, user_id, title, content, tags, created_at
FROM notes
WHERE id = $1 AND (user_id = $2 OR is_public = true)
LIMIT 1
`

type GetNoteForFlashcardParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetNoteForFlashcardRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetNoteForFlashcard(ctx context.Context, arg GetNoteForFlashcardParams) (GetNoteForFlashcardRow, error) {
	row := q.db.QueryRow(ctx, getNoteForFlashcard, arg.ID, arg.UserID)
	var i GetNoteForFlashcardRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}

const getPublicNotes = `-- name: GetPublicNotes :many
SELECT id, user_id, title, content, tags, is_public, created_at, updated_at
FROM notes
WHERE is_public = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetPublicNotesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPublicNotesRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	IsPublic  pgtype.Bool        `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPublicNotes(ctx context.Context, arg GetPublicNotesParams) ([]GetPublicNotesRow, error) {
	rows, err := q.db.Query(ctx, getPublicNotes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublicNotesRow{}
	for rows.Next() {
		var i GetPublicNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.Tags,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotes = `-- name: GetUserNotes :many
SELECT id, user_id, title, content, tags, is_public, created_at, updated_at
FROM notes
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetUserNotesRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	IsPublic  pgtype.Bool        `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserNotes(ctx context.Context, arg GetUserNotesParams) ([]GetUserNotesRow, error) {
	rows, err := q.db.Query(ctx, getUserNotes, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserNotesRow{}
	for rows.Next() {
		var i GetUserNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.Tags,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNotesBySimilarity = `-- name: SearchNotesBySimilarity :many
SELECT 
    n.id,
    n.user_id,
    n.title,
    n.content,
    n.tags,
    n.is_public,
    n.created_at,
    n.updated_at,
    (1 - (n.embedding <=> $1::vector))::float AS similarity
FROM notes n
WHERE 
    (n.user_id = $2 OR n.is_public = true)
    AND n.embedding IS NOT NULL
    AND 1 - (n.embedding <=> $1::vector) > $3::float
ORDER BY n.embedding <=> $1::vector
LIMIT $4
`

type SearchNotesBySimilarityParams struct {
	Column1 pgvector.Vector `json:"column_1"`
	UserID  pgtype.UUID     `json:"user_id"`
	Column3 float64         `json:"column_3"`
	Limit   int32           `json:"limit"`
}

type SearchNotesBySimilarityRow struct {
	ID         pgtype.UUID        `json:"id"`
	UserID     pgtype.UUID        `json:"user_id"`
	Title      string             `json:"title"`
	Content    string             `json:"content"`
	Tags       []string           `json:"tags"`
	IsPublic   pgtype.Bool        `json:"is_public"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	Similarity float64            `json:"similarity"`
}

func (q *Queries) SearchNotesBySimilarity(ctx context.Context, arg SearchNotesBySimilarityParams) ([]SearchNotesBySimilarityRow, error) {
	rows, err := q.db.Query(ctx, searchNotesBySimilarity,
		arg.Column1,
		arg.UserID,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchNotesBySimilarityRow{}
	for rows.Next() {
		var i SearchNotesBySimilarityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.Tags,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNote = `-- name: UpdateNote :one
UPDATE notes
SET 
    title = COALESCE($2, title),
    content = COALESCE($3, content),
    embedding = COALESCE($4, embedding),
    tags = COALESCE($5, tags),
    is_public = COALESCE($6, is_public),
    updated_at = NOW()
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, title, content, tags, is_public, created_at, updated_at
`

type UpdateNoteParams struct {
	ID        pgtype.UUID     `json:"id"`
	Title     string          `json:"title"`
	Content   string          `json:"content"`
	Embedding pgvector.Vector `json:"embedding"`
	Tags      []string        `json:"tags"`
	IsPublic  pgtype.Bool     `json:"is_public"`
	UserID    pgtype.UUID     `json:"user_id"`
}

type UpdateNoteRow struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Title     string             `json:"title"`
	Content   string             `json:"content"`
	Tags      []string           `json:"tags"`
	IsPublic  pgtype.Bool        `json:"is_public"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) (UpdateNoteRow, error) {
	row := q.db.QueryRow(ctx, updateNote,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Embedding,
		arg.Tags,
		arg.IsPublic,
		arg.UserID,
	)
	var i UpdateNoteRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.Tags,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
